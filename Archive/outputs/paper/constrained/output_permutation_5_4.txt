Running solver...
Choice set:dom2 ([4,5])
----------
Solving 4 vars:
	universe ([1,5])
	dom2 ([4,5])
	universe ([1,5])
	universe ([1,5])
Choice constraints:
	Position 2: dom2 ([4,5])
Count constraints:
	Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 2
----------
Counting non-exchangeable...
Solving combination 0: ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0'] // ['Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 2']
	Split class: universe ([1,5])
	Computing case combinations of rest classes...
	Case (1, 2)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			Nr. ¬(dom2) ([1,4)) == 1
			Nr. dom2 ([4,5]) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 1
					Nr. dom2 ([4,5]) == 2
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ([1,4)) == 1
					3 exchangeable free vars: ¬(dom2 ∧ ¬(dom1)) ([1,4])
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,4))
							¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
							¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
						Choice constraints:
						Count constraints:
							Nr. dom2 ([4,5]) == 2
						----------
						Counting non-exchangeable...
						Solving combination 0: ['Nr. dom2 ([4,5]) == 0'] // ['Nr. dom2 ([4,5]) == 2']
							Split class: ¬(dom2) ([1,4))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 0', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ([1,4))
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 3
													Counting domains: 3
												=========
												tot:3
										=========
										tot:3
								=========
								tot:3
							Filtering domains...
							  Case ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5])
							  Filtering 1 ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) out of ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]):
							  Filtering 1 ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) out of ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]):
							  Case ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
									¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									2 different vars for 1 values!
									Counting domains: 0
								=========
								tot:0
							Split result = 0
							Case (0, 1)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 0', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						Solving combination 1: ['Nr. dom2 ([4,5]) == 1'] // ['Nr. dom2 ([4,5]) == 1']
							Split class: ¬(dom2) ([1,4))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 1', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
							Case (0, 1)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 1', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						Solving combination 2: ['Nr. dom2 ([4,5]) == 2'] // ['Nr. dom2 ([4,5]) == 0']
							Split class: ¬(dom2) ([1,4))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 2', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 is unsat here
								==========
								Unsat: 0
							Case (0, 1)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 2', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (2, 1)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			Nr. ¬(dom2) ([1,4)) == 2
			Nr. dom2 ([4,5]) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 2
					Nr. dom2 ([4,5]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ([1,4)) == 2
					3 exchangeable free vars: ¬(dom2 ∧ ¬(dom1)) ([1,4])
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,4))
							¬(dom2) ([1,4))
							¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
						Choice constraints:
						Count constraints:
							Nr. dom2 ([4,5]) == 1
						----------
						Counting non-exchangeable...
						Solving combination 0: ['Nr. dom2 ([4,5]) == 0'] // ['Nr. dom2 ([4,5]) == 1']
							Split class: ¬(dom2) ([1,4))
							Computing case combinations of rest classes...
							Case (1, 1)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 0', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ([1,4))
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (0, 2)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 0', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 2']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ([1,4))
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (2, 0)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 0', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ([1,4))
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 2
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 2
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ([1,4))
													¬(dom2) ([1,4))
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 6
													Counting domains: 6
												=========
												tot:6
										=========
										tot:6
								=========
								tot:6
							Filtering domains...
							  Case ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5])
							  Filtering 2 ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) out of ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]):
							  Case ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 1
									Counting domains: 1
								=========
								tot:1
							Split result = 6
						Solving combination 1: ['Nr. dom2 ([4,5]) == 1'] // ['Nr. dom2 ([4,5]) == 0']
							Split class: ¬(dom2) ([1,4))
							Computing case combinations of rest classes...
							Case (1, 1)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 1', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
							Case (0, 2)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 1', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 2']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
							Case (2, 0)
							Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 1', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:6
				=========
				tot:18
		=========
		tot:18
	Filtering domains...
	  Case ¬(dom2) ([1,4))
	  Filtering 2 ¬(dom2) ([1,4)) out of dom2 ([4,5]):
	  Case dom2 ([4,5])
	  Filtering 1 dom2 ([4,5]) out of dom2 ([4,5]):
		Subproblem:
		----------
		Solving 1 vars:
			dom2 ∧ ¬(dom2) ((4,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 2
			Expanding bounds [0,2]...
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
				==========
				Unsat: 0
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 already satisfied
					Splitting on other constraints...
					... no other constraints
					Counting permutations:
					Falling factorial: 1
					Counting domains: 1
				=========
				tot:1
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2 is unsat here
				==========
				Unsat: 0
		=========
		tot:1
	Split result = 18
	Case (0, 3)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			Nr. ¬(dom2) ([1,4)) == 0
			Nr. dom2 ([4,5]) == 3
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 0
					Nr. dom2 ([4,5]) == 3
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ([1,4)) == 0
					3 exchangeable free vars: ¬(dom2 ∧ ¬(dom1)) ([1,4])
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
							¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
							¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
						Choice constraints:
						Count constraints:
							Nr. dom2 ([4,5]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. dom2 ([4,5]) == 3
							Nr. dom2 ([4,5]) == 3 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							3 different vars for 1 values!
							Counting domains: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (3, 0)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			Nr. ¬(dom2) ([1,4)) == 3
			Nr. dom2 ([4,5]) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 3
					Nr. dom2 ([4,5]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ([1,4)) == 3
					3 exchangeable free vars: ¬(dom2 ∧ ¬(dom1)) ([1,4])
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,4))
							¬(dom2) ([1,4))
							¬(dom2) ([1,4))
						Choice constraints:
						Count constraints:
							Nr. dom2 ([4,5]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. dom2 ([4,5]) == 0
							Nr. dom2 ([4,5]) == 0 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 6
							Counting domains: 6
						=========
						tot:6
				=========
				tot:6
		=========
		tot:6
	Filtering domains...
	  Case ¬(dom2) ([1,4))
	  Filtering 3 ¬(dom2) ([1,4)) out of dom2 ([4,5]):
	  Case dom2 ([4,5])
		Subproblem:
		----------
		Solving 1 vars:
			dom2 ([4,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 2
			Expanding bounds [0,2]...
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ([4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
					1 exchangeable free vars: dom2 ([4,5])
					Splitting on other constraints...
					... no other constraints
					Counting permutations:
					Falling factorial: 1
					Counting domains: 1
				=========
				tot:1
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ([4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
					1 exchangeable free vars: dom2 ([4,5])
					Splitting on other constraints...
					... no other constraints
					Counting permutations:
					Falling factorial: 1
					Counting domains: 1
				=========
				tot:1
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ([4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
					1 exchangeable free vars: dom2 ([4,5])
				==========
				Unsat: 0
		=========
		tot:2
	Split result = 12
Solving combination 1: ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1'] // ['Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 1']
	Split class: universe ([1,5])
	Computing case combinations of rest classes...
	Case (1, 2)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			Nr. ¬(dom2) ([1,4)) == 1
			Nr. dom2 ([4,5]) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 1
					Nr. dom2 ([4,5]) == 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ∧ ¬(dom1) ((4,5])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 1
													Counting domains: 1
												=========
												tot:1
										=========
										tot:1
								=========
								tot:1
						=========
						tot:1
					Filtering domains...
					  Case dom2 ∧ ¬(dom1) ((4,5])
					  Filtering 1 dom2 ∧ ¬(dom1) ((4,5]) out of ¬(dom2 ∧ ¬(dom1)) ([1,4]):
					  Filtering 1 dom2 ∧ ¬(dom1) ((4,5]) out of ¬(dom2 ∧ ¬(dom1)) ([1,4]):
					  Case ¬(dom2 ∧ ¬(dom1)) ([1,4])
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2 ∧ ¬(dom1)) ([1,4])
							¬(dom2 ∧ ¬(dom1)) ([1,4])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							2 exchangeable free vars: ¬(dom2 ∧ ¬(dom1)) ([1,4])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. dom2 ([4,5]) == 0'] // ['Nr. dom2 ([4,5]) == 1']
									Split class: ¬(dom2) ([1,4))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 0', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. dom2 ([4,5]) == 0
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([4,5]) == 0
											Nr. dom2 ([4,5]) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ([1,4))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
													Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
													Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ([1,4))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
															Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 3
															Counting domains: 3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5])
									  Filtering 1 ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) out of ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]):
									  Case ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([4,5]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([4,5]) == 1
											Nr. dom2 ([4,5]) == 1 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 1
											Counting domains: 1
										=========
										tot:1
									Split result = 3
									Case (0, 1)
									Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 0', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. dom2 ([4,5]) == 0
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([4,5]) == 0
											Nr. dom2 ([4,5]) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ([1,4))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
													Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 1: ['Nr. dom2 ([4,5]) == 1'] // ['Nr. dom2 ([4,5]) == 0']
									Split class: ¬(dom2) ([1,4))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 1', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. dom2 ([4,5]) == 1
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([4,5]) == 1
											Nr. dom2 ([4,5]) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ([1,4)) are ['Nr. dom2 ([4,5]) == 1', 'Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ([1,4))
										Choice constraints:
										Count constraints:
											Nr. dom2 ([4,5]) == 1
											Nr. ¬(¬(dom2 ∧ ¬(dom1)) ∧ dom2) ([1,4) | (4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([4,5]) == 1
											Nr. dom2 ([4,5]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:3
						=========
						tot:6
					Split result = 6
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:6
		=========
		tot:18
	Filtering domains...
	  Case ¬(dom2) ([1,4))
	  Filtering 1 ¬(dom2) ([1,4)) out of dom2 ([4,5]):
	  Case dom2 ([4,5])
	  Filtering 2 dom2 ([4,5]) out of dom2 ([4,5]):
		Subproblem:
		----------
		Solving 1 vars:
			dom2 ∧ ¬(dom2) ((4,5))
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 1
			Expanding bounds [0,1]...
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((4,5))
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
				==========
				Unsat: 0
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((4,5))
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 already satisfied
					Splitting on other constraints...
					... no other constraints
					Counting permutations:
					1 different vars for 0 values!
					Counting domains: 0
				=========
				tot:0
		=========
		tot:0
	Split result = 0
	Case (2, 1)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			Nr. ¬(dom2) ([1,4)) == 2
			Nr. dom2 ([4,5]) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 2
					Nr. dom2 ([4,5]) == 1
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ∧ ¬(dom1) ((4,5])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 1
													Counting domains: 1
												=========
												tot:1
										=========
										tot:1
								=========
								tot:1
						=========
						tot:1
					Filtering domains...
					  Case dom2 ∧ ¬(dom1) ((4,5])
					  Filtering 1 dom2 ∧ ¬(dom1) ((4,5]) out of ¬(dom2 ∧ ¬(dom1)) ([1,4]):
					  Filtering 1 dom2 ∧ ¬(dom1) ((4,5]) out of ¬(dom2 ∧ ¬(dom1)) ([1,4]):
					  Case ¬(dom2 ∧ ¬(dom1)) ([1,4])
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2 ∧ ¬(dom1)) ([1,4])
							¬(dom2 ∧ ¬(dom1)) ([1,4])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							2 exchangeable free vars: ¬(dom2 ∧ ¬(dom1)) ([1,4])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ([1,4))
									¬(dom2) ([1,4))
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 6
									Counting domains: 6
								=========
								tot:6
						=========
						tot:6
					Split result = 6
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
				=========
				tot:6
		=========
		tot:18
	Filtering domains...
	  Case ¬(dom2) ([1,4))
	  Filtering 2 ¬(dom2) ([1,4)) out of dom2 ([4,5]):
	  Case dom2 ([4,5])
	  Filtering 1 dom2 ([4,5]) out of dom2 ([4,5]):
		Subproblem:
		----------
		Solving 1 vars:
			dom2 ∧ ¬(dom2) ((4,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 1
			Expanding bounds [0,1]...
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
				==========
				Unsat: 0
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((4,5])
				Choice constraints:
				Count constraints:
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
					Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 already satisfied
					Splitting on other constraints...
					... no other constraints
					Counting permutations:
					Falling factorial: 1
					Counting domains: 1
				=========
				tot:1
		=========
		tot:1
	Split result = 18
	Case (0, 3)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			Nr. ¬(dom2) ([1,4)) == 0
			Nr. dom2 ([4,5]) == 3
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 0
					Nr. dom2 ([4,5]) == 3
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ∧ ¬(dom1) ((4,5])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 1
													Counting domains: 1
												=========
												tot:1
										=========
										tot:1
								=========
								tot:1
						=========
						tot:1
					Filtering domains...
					  Case dom2 ∧ ¬(dom1) ((4,5])
					  Filtering 1 dom2 ∧ ¬(dom1) ((4,5]) out of ¬(dom2 ∧ ¬(dom1)) ([1,4]):
					  Filtering 1 dom2 ∧ ¬(dom1) ((4,5]) out of ¬(dom2 ∧ ¬(dom1)) ([1,4]):
					  Case ¬(dom2 ∧ ¬(dom1)) ([1,4])
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2 ∧ ¬(dom1)) ([1,4])
							¬(dom2 ∧ ¬(dom1)) ([1,4])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							2 exchangeable free vars: ¬(dom2 ∧ ¬(dom1)) ([1,4])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
									¬(dom2 ∧ ¬(dom1)) ∧ dom2 ([4])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									2 different vars for 1 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 3
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 3
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 3
									Nr. dom2 ([4,5]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 3
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 3
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 3
									Nr. dom2 ([4,5]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (3, 0)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			Nr. ¬(dom2) ([1,4)) == 3
			Nr. dom2 ([4,5]) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 3
					Nr. dom2 ([4,5]) == 0
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 3
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 3
							Nr. ¬(dom2) ([1,4)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 3
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 3
							Nr. ¬(dom2) ([1,4)) == 3 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
Solving combination 2: ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2'] // ['Nr. dom2 ∧ ¬(dom1) ((4,5]) =< 0']
	Split class: universe ([1,5])
	Computing case combinations of rest classes...
	Case (1, 2)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			Nr. ¬(dom2) ([1,4)) == 1
			Nr. dom2 ([4,5]) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 1
					Nr. dom2 ([4,5]) == 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ∧ ¬(dom1) ((4,5])
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ∧ ¬(dom1) ((4,5])
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ∧ ¬(dom1) ((4,5])
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													dom2 ∧ ¬(dom1) ((4,5])
													dom2 ∧ ¬(dom1) ((4,5])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													2 different vars for 1 values!
													Counting domains: 0
												=========
												tot:0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (2, 1)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			Nr. ¬(dom2) ([1,4)) == 2
			Nr. dom2 ([4,5]) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 2
					Nr. dom2 ([4,5]) == 1
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (0, 3)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			Nr. ¬(dom2) ([1,4)) == 0
			Nr. dom2 ([4,5]) == 3
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 0
					Nr. dom2 ([4,5]) == 3
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 1
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 1
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 1
									Nr. dom2 ([4,5]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 1']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ∧ ¬(dom1) ((4,5])
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ∧ ¬(dom1) ((4,5])
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 2', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 2
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 2
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 2
									Nr. dom2 ([4,5]) == 2 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ∧ ¬(dom1) ((4,5])
											dom2 ∧ ¬(dom1) ((4,5])
										Choice constraints:
										Count constraints:
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
											Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
											Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													dom2 ∧ ¬(dom1) ((4,5])
													dom2 ∧ ¬(dom1) ((4,5])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
													Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													2 different vars for 1 values!
													Counting domains: 0
												=========
												tot:0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 3
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 3
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 3
									Nr. dom2 ([4,5]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 3
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 3
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 3
									Nr. dom2 ([4,5]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 3', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 3
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 3
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 3
									Nr. dom2 ([4,5]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (3, 0)
	Case universe ([1,5]) are ['Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0']:
		Subproblem:
		----------
		Solving 3 vars:
			universe ([1,5])
			universe ([1,5])
			universe ([1,5])
		Choice constraints:
		Count constraints:
			Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			Nr. ¬(dom2) ([1,4)) == 3
			Nr. dom2 ([4,5]) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
			3 exchangeable free vars: universe ([1,5])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 3 vars:
					dom2 ∧ ¬(dom1) ((4,5])
					dom2 ∧ ¬(dom1) ((4,5])
					¬(dom2 ∧ ¬(dom1)) ([1,4])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ([1,4)) == 3
					Nr. dom2 ([4,5]) == 0
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 0
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 0
							Nr. ¬(dom2) ([1,4)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ∧ ¬(dom1) ((4,5])
									dom2 ∧ ¬(dom1) ((4,5])
								Choice constraints:
								Count constraints:
									Nr. dom2 ([4,5]) == 0
									Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
									Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. dom2 ([4,5]) == 0
									Nr. dom2 ([4,5]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 1
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 1
							Nr. ¬(dom2) ([1,4)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 2: ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 1', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 2', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 2
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 2
							Nr. ¬(dom2) ([1,4)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0'] // ['Nr. ¬(dom2) ([1,4)) == 0', 'Nr. dom2 ([4,5]) == 0']
					Split class: dom2 ∧ ¬(dom1) ((4,5])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 3
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 1
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 3
							Nr. ¬(dom2) ([1,4)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 3
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 0
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 3
							Nr. ¬(dom2) ([1,4)) == 3 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ∧ ¬(dom1) ((4,5]) are ['Nr. ¬(dom2) ([1,4)) == 3', 'Nr. dom2 ([4,5]) == 0', 'Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2', 'Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ∧ ¬(dom1) ((4,5])
							dom2 ∧ ¬(dom1) ((4,5])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ([1,4)) == 3
							Nr. dom2 ([4,5]) == 0
							Nr. dom2 ∧ ¬(dom1) ((4,5]) == 2
							Nr. ¬(dom2 ∧ ¬(dom1)) ([1,4]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ([1,4)) == 3
							Nr. ¬(dom2) ([1,4)) == 3 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
=========
tot:48

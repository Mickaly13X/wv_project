Running solver...
Choice set:dom2 ([5,10])
Choice set:dom1 ([3,10])
----------
Solving 8 vars:
	universe ([1,10])
	universe ([1,10])
	universe ([1,10])
	dom2 ([5,10])
	universe ([1,10])
	dom1 ([3,10])
	universe ([1,10])
	universe ([1,10])
Choice constraints:
	Position 4: dom2 ([5,10])
	Position 6: dom1 ([3,10])
Count constraints:
----------
Counting permutations:
Splitting injectivity...
	Split class: universe ([1,10])
	Computing case combinations of rest classes...
	Case (1, 1, 4)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 4']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 1
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
			Nr. ¬(dom1) ([1,3)) == 4
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 1
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
					Nr. ¬(dom1) ([1,3)) == 4
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 4']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 6
													Counting domains: 6
												=========
												tot:6
										=========
										tot:6
								=========
								tot:6
						=========
						tot:6
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							5 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 2
															Counting domains: 2
														=========
														tot:2
												=========
												tot:2
										=========
										tot:2
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 4
											Nr. ¬(dom1) ([1,3)) == 4 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											4 different vars for 2 values!
											Counting domains: 0
										=========
										tot:0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom1) ([1,3)) == 4'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 4
											Nr. ¬(dom1) ([1,3)) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 4
											Nr. ¬(dom1) ([1,3)) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 6: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 7: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 8: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 9: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 4'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (4, 1, 1)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 4
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
			Nr. ¬(dom1) ([1,3)) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 4
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
					Nr. ¬(dom1) ([1,3)) == 1
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 4
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 4
											Nr. dom2 ([5,10]) == 4 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 360
													Counting domains: 360
												=========
												tot:360
										=========
										tot:360
								=========
								tot:360
						=========
						tot:360
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 4 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 4 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							2 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 2
															Counting domains: 2
														=========
														tot:2
												=========
												tot:2
										=========
										tot:2
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 2
											Counting domains: 2
										=========
										tot:2
									Split result = 4
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:4
						=========
						tot:8
					Split result = 2880
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:2880
		=========
		tot:43200
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 4 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 4 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Filtering 1 ¬(dom2) ∧ dom1 ([3,5)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]):
	  Filtering 1 ¬(dom2) ∧ dom1 ([3,5)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]):
	  Case ¬(dom1) ([1,3))
	  Filtering 1 ¬(dom1) ([1,3)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]):
	  Filtering 1 ¬(dom1) ([1,3)) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]):
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
			dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 1', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 1
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 0', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 0
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 2
							Counting domains: 2
						=========
						tot:2
				=========
				tot:2
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8])
			  Case dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ∧ ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 2
				Counting domains: 2
				=========
				tot:2
			Split result = 4
		Counting domains: 4
		=========
		tot:4
	Split result = 172800
	Case (1, 4, 1)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 1']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 1
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
			Nr. ¬(dom1) ([1,3)) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 1
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
					Nr. ¬(dom1) ([1,3)) == 1
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 6
													Counting domains: 6
												=========
												tot:6
										=========
										tot:6
								=========
								tot:6
						=========
						tot:6
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							5 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (3, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (1, 3)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (2, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (4, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 4 vars:
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															4 different vars for 2 values!
															Counting domains: 0
														=========
														tot:0
												=========
												tot:0
										=========
										tot:0
									Case (0, 4)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (3, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (1, 3)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (2, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (4, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 4)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4']:
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 6: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				Solving combination 7: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				Solving combination 8: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
				Solving combination 9: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (1, 3, 2)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 2']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 1
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
			Nr. ¬(dom1) ([1,3)) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 1
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
					Nr. ¬(dom1) ([1,3)) == 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 6
													Counting domains: 6
												=========
												tot:6
										=========
										tot:6
								=========
								tot:6
						=========
						tot:6
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							5 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (2, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 3)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (3, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 3 vars:
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															3 different vars for 2 values!
															Counting domains: 0
														=========
														tot:0
												=========
												tot:0
										=========
										tot:0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (2, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 3)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (3, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (2, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 3)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (3, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 6: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 7: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 8: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 9: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				Solving combination 10: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				Solving combination 11: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (1, 2, 3)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 3']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 1
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
			Nr. ¬(dom1) ([1,3)) == 3
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 1
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
					Nr. ¬(dom1) ([1,3)) == 3
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 6
													Counting domains: 6
												=========
												tot:6
										=========
										tot:6
								=========
								tot:6
						=========
						tot:6
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							5 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 2 vars:
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 2
															Counting domains: 2
														=========
														tot:2
												=========
												tot:2
										=========
										tot:2
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
									  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											3 different vars for 2 values!
											Counting domains: 0
										=========
										tot:0
									Split result = 0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 is unsat here
										==========
										Unsat: 0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 6: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 7: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 8: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 9: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 10: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 11: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (2, 1, 3)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 2
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
			Nr. ¬(dom1) ([1,3)) == 3
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 2
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
					Nr. ¬(dom1) ([1,3)) == 3
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 30
													Counting domains: 30
												=========
												tot:30
										=========
										tot:30
								=========
								tot:30
						=========
						tot:30
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							4 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 2
															Counting domains: 2
														=========
														tot:2
												=========
												tot:2
										=========
										tot:2
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											3 different vars for 2 values!
											Counting domains: 0
										=========
										tot:0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 3
											Nr. ¬(dom1) ([1,3)) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 6: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 7: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (3, 2, 1)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 3
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
			Nr. ¬(dom1) ([1,3)) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 3
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
					Nr. ¬(dom1) ([1,3)) == 1
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 120
													Counting domains: 120
												=========
												tot:120
										=========
										tot:120
								=========
								tot:120
						=========
						tot:120
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							3 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 2 vars:
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 2
															Counting domains: 2
														=========
														tot:2
												=========
												tot:2
										=========
										tot:2
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
									  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 2
											Counting domains: 2
										=========
										tot:2
									Split result = 4
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:4
						=========
						tot:12
					Split result = 1440
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				=========
				tot:1440
		=========
		tot:28800
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 3 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 3 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Filtering 2 ¬(dom2) ∧ dom1 ([3,5)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]):
	  Filtering 2 ¬(dom2) ∧ dom1 ([3,5)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,10]):
	  Case ¬(dom1) ([1,3))
	  Filtering 1 ¬(dom1) ([1,3)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]):
	  Filtering 1 ¬(dom1) ([1,3)) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]):
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
			dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 1', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 1
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 0', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 0
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 3
							Counting domains: 3
						=========
						tot:3
				=========
				tot:3
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7])
			  Case dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ∧ ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 2
				Counting domains: 2
				=========
				tot:2
			Split result = 6
		Counting domains: 6
		=========
		tot:6
	Split result = 172800
	Case (3, 1, 2)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 3
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
			Nr. ¬(dom1) ([1,3)) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 3
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
					Nr. ¬(dom1) ([1,3)) == 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 120
													Counting domains: 120
												=========
												tot:120
										=========
										tot:120
								=========
								tot:120
						=========
						tot:120
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							3 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 2
															Counting domains: 2
														=========
														tot:2
												=========
												tot:2
										=========
										tot:2
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 2
											Counting domains: 2
										=========
										tot:2
									Split result = 4
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:4
						=========
						tot:12
					Split result = 1440
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:1440
		=========
		tot:28800
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 3 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 3 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Filtering 1 ¬(dom2) ∧ dom1 ([3,5)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]):
	  Filtering 1 ¬(dom2) ∧ dom1 ([3,5)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,10]):
	  Case ¬(dom1) ([1,3))
	  Filtering 2 ¬(dom1) ([1,3)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]):
	  Filtering 2 ¬(dom1) ([1,3)) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]):
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
			dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 1', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 1
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 0', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 0
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 3
							Counting domains: 3
						=========
						tot:3
				=========
				tot:3
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7])
			  Case dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ∧ ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 3
				Counting domains: 3
				=========
				tot:3
			Split result = 9
		Counting domains: 9
		=========
		tot:9
	Split result = 259200
	Case (2, 3, 1)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 2
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
			Nr. ¬(dom1) ([1,3)) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 2
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
					Nr. ¬(dom1) ([1,3)) == 1
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 30
													Counting domains: 30
												=========
												tot:30
										=========
										tot:30
								=========
								tot:30
						=========
						tot:30
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							4 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (2, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 3)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (3, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 3 vars:
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															3 different vars for 2 values!
															Counting domains: 0
														=========
														tot:0
												=========
												tot:0
										=========
										tot:0
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (2, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 3)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (3, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 6: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				Solving combination 7: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (5, 0, 1)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 5', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 5
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
			Nr. ¬(dom1) ([1,3)) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 5
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom1) ([1,3)) == 1
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (4, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 4
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 4
											Nr. dom2 ([5,10]) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (5, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 5', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 5
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 5
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 5
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 5
											Nr. dom2 ([5,10]) == 5 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 5 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 720
													Counting domains: 720
												=========
												tot:720
										=========
										tot:720
								=========
								tot:720
						=========
						tot:720
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 5 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 1 vars:
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							1 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 2
									Counting domains: 2
								=========
								tot:2
						=========
						tot:2
					Split result = 1440
					Case (0, 5)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 5']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 5
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (4, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (1, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (5, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 5', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 5
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 5
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 5)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 5']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:1440
		=========
		tot:8640
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 5 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 5 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Case ¬(dom1) ([1,3))
	  Filtering 1 ¬(dom1) ([1,3)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10]):
	  Filtering 1 ¬(dom1) ([1,3)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]):
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
			dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 1', 'Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 1
					Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 0', 'Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 0
					Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 1
							Counting domains: 1
						=========
						tot:1
				=========
				tot:1
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9])
			  Case dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(dom1 ∧ ¬(dom2)) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 2
				Counting domains: 2
				=========
				tot:2
			Split result = 2
		Counting domains: 2
		=========
		tot:2
	Split result = 17280
	Case (1, 5, 0)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5', 'Nr. ¬(dom1) ([1,3)) == 0']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 1
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
			Nr. ¬(dom1) ([1,3)) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 1
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
					Nr. ¬(dom1) ([1,3)) == 0
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 6
													Counting domains: 6
												=========
												tot:6
										=========
										tot:6
								=========
								tot:6
						=========
						tot:6
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
							Nr. ¬(dom1) ([1,3)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
							5 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									5 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5 is unsat here
						==========
						Unsat: 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (0, 1, 5)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 5']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
			Nr. ¬(dom1) ([1,3)) == 5
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 0
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
					Nr. ¬(dom1) ([1,3)) == 5
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
					6 exchangeable free vars: ¬(dom2) ([1,5))
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 5
						----------
						Counting non-exchangeable...
						Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 5']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 2
													Counting domains: 2
												=========
												tot:2
										=========
										tot:2
								=========
								tot:2
							Filtering domains...
							  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
							  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(dom1) ([1,3)) == 5 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									5 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
							Split result = 0
							Case (0, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 4']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (0, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 3']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (0, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						Solving combination 3: ['Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom1) ([1,3)) == 2']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
							Case (0, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						Solving combination 4: ['Nr. ¬(dom1) ([1,3)) == 4'] // ['Nr. ¬(dom1) ([1,3)) == 1']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
							Case (0, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						Solving combination 5: ['Nr. ¬(dom1) ([1,3)) == 5'] // ['Nr. ¬(dom1) ([1,3)) == 0']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(dom1) ([1,3)) == 5 is unsat here
								==========
								Unsat: 0
							Case (0, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(dom1) ([1,3)) == 5 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (5, 1, 0)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 5', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 5
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
			Nr. ¬(dom1) ([1,3)) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 5
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
					Nr. ¬(dom1) ([1,3)) == 0
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (4, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 4
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 4
											Nr. dom2 ([5,10]) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (5, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 5', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 5
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 5
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 5
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 5
											Nr. dom2 ([5,10]) == 5 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 5 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 720
													Counting domains: 720
												=========
												tot:720
										=========
										tot:720
								=========
								tot:720
						=========
						tot:720
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 5 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 1 vars:
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							1 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 2
									Counting domains: 2
								=========
								tot:2
						=========
						tot:2
					Split result = 1440
					Case (0, 5)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 5']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 5
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (4, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (1, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (3, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (5, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 5', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 5
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 5)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 5']:
						Subproblem:
						----------
						Solving 5 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:1440
		=========
		tot:8640
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 5 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 5 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Filtering 1 ¬(dom2) ∧ dom1 ([3,5)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10]):
	  Filtering 1 ¬(dom2) ∧ dom1 ([3,5)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]):
	  Case ¬(dom1) ([1,3))
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
			dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 1', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 1
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 0', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 0
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 1
							Counting domains: 1
						=========
						tot:1
				=========
				tot:1
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [5] | [6] | [7] | [8] | [9])
			  Case dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ∧ ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 1
				Counting domains: 1
				=========
				tot:1
			Split result = 1
		Counting domains: 1
		=========
		tot:1
	Split result = 8640
	Case (0, 5, 1)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5', 'Nr. ¬(dom1) ([1,3)) == 1']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
			Nr. ¬(dom1) ([1,3)) == 1
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 0
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
					Nr. ¬(dom1) ([1,3)) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 5
					6 exchangeable free vars: ¬(dom2) ([1,5))
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 1
						----------
						Counting non-exchangeable...
						Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 1']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (4, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (1, 4)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (2, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (3, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (5, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 5', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 5
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 5
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 5 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 5 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													5 different vars for 2 values!
													Counting domains: 0
												=========
												tot:0
										=========
										tot:0
								=========
								tot:0
							Case (0, 5)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 5']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 5
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 0']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (4, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (1, 4)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (2, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (3, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (5, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 5', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 5
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (0, 5)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 5']:
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (1, 0, 5)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 5']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 1
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
			Nr. ¬(dom1) ([1,3)) == 5
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 1
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom1) ([1,3)) == 5
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 5']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 6
													Counting domains: 6
												=========
												tot:6
										=========
										tot:6
								=========
								tot:6
						=========
						tot:6
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 1 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							5 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(dom1) ([1,3)) == 5 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									5 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 5'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 5', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 5
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 5
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(dom1) ([1,3)) == 5 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 5', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 5
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 5
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 5
									Nr. ¬(dom1) ([1,3)) == 5 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (2, 2, 2)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 2
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
			Nr. ¬(dom1) ([1,3)) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 2
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
					Nr. ¬(dom1) ([1,3)) == 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 30
													Counting domains: 30
												=========
												tot:30
										=========
										tot:30
								=========
								tot:30
						=========
						tot:30
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							4 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 0
											Nr. ¬(dom1) ([1,3)) == 0 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 2 vars:
															¬(dom2) ∧ dom1 ([3,5))
															¬(dom2) ∧ dom1 ([3,5))
														Choice constraints:
														Count constraints:
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
															Splitting on other constraints...
															... no other constraints
															Counting permutations:
															Falling factorial: 2
															Counting domains: 2
														=========
														tot:2
												=========
												tot:2
										=========
										tot:2
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
									  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 2
											Counting domains: 2
										=========
										tot:2
									Split result = 4
								Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 1
											Nr. ¬(dom1) ([1,3)) == 1 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,5))
									Computing case combinations of rest classes...
									Case (1, 1)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 2)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
									Case (2, 0)
									Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom1) ([1,3)) == 2
											Nr. ¬(dom1) ([1,3)) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:4
						=========
						tot:24
					Split result = 720
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 5: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 6: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 7: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 8: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				=========
				tot:720
		=========
		tot:10800
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 2 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 2 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Filtering 2 ¬(dom2) ∧ dom1 ([3,5)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,10]):
	  Filtering 2 ¬(dom2) ∧ dom1 ([3,5)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,10]):
	  Case ¬(dom1) ([1,3))
	  Filtering 2 ¬(dom1) ([1,3)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,10]):
	  Filtering 2 ¬(dom1) ([1,3)) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]):
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,10])
			dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 1', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 1
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 0', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 0
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 4
							Counting domains: 4
						=========
						tot:4
				=========
				tot:4
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6])
			  Case dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ∧ ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ((3,4) | (4,5) | (5,6) | (6,7) | (7,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 3
				Counting domains: 3
				=========
				tot:3
			Split result = 12
		Counting domains: 12
		=========
		tot:12
	Split result = 129600
	Case (0, 2, 4)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 4']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
			Nr. ¬(dom1) ([1,3)) == 4
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 0
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
					Nr. ¬(dom1) ([1,3)) == 4
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
					6 exchangeable free vars: ¬(dom2) ([1,5))
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 4
						----------
						Counting non-exchangeable...
						Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 4']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (0, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (2, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 2
													Counting domains: 2
												=========
												tot:2
										=========
										tot:2
								=========
								tot:2
							Filtering domains...
							  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10])
							  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Filtering 2 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)):
							  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									4 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
							Split result = 0
						Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 3']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (0, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (2, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 2']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (0, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (2, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						Solving combination 3: ['Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom1) ([1,3)) == 1']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
							Case (0, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
							Case (2, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						Solving combination 4: ['Nr. ¬(dom1) ([1,3)) == 4'] // ['Nr. ¬(dom1) ([1,3)) == 0']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
							Case (0, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
							Case (2, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (2, 4, 0)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 2
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
			Nr. ¬(dom1) ([1,3)) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 2
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
					Nr. ¬(dom1) ([1,3)) == 0
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 30
													Counting domains: 30
												=========
												tot:30
										=========
										tot:30
								=========
								tot:30
						=========
						tot:30
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							4 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									4 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (2, 0, 4)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 2
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
			Nr. ¬(dom1) ([1,3)) == 4
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 2
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom1) ([1,3)) == 4
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 30
													Counting domains: 30
												=========
												tot:30
										=========
										tot:30
								=========
								tot:30
						=========
						tot:30
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 2 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							4 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									4 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 4: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 4', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 4
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 4
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 4
									Nr. ¬(dom1) ([1,3)) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (4, 2, 0)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 4
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
			Nr. ¬(dom1) ([1,3)) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 4
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
					Nr. ¬(dom1) ([1,3)) == 0
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 4
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 4
											Nr. dom2 ([5,10]) == 4 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 360
													Counting domains: 360
												=========
												tot:360
										=========
										tot:360
								=========
								tot:360
						=========
						tot:360
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 4 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 4 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							2 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 2
									Counting domains: 2
								=========
								tot:2
						=========
						tot:2
					Split result = 720
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				=========
				tot:720
		=========
		tot:10800
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 4 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 4 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Filtering 2 ¬(dom2) ∧ dom1 ([3,5)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]):
	  Filtering 2 ¬(dom2) ∧ dom1 ([3,5)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]):
	  Case ¬(dom1) ([1,3))
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
			dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 1', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 1
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 0', 'Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 0
					Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 2
							Counting domains: 2
						=========
						tot:2
				=========
				tot:2
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([1,3] | [4] | [5] | [6] | [7] | [8])
			  Case dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]) out of dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ∧ ¬(dom1 ∧ ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ((3,4) | (4,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 1
				Counting domains: 1
				=========
				tot:1
			Split result = 2
		Counting domains: 2
		=========
		tot:2
	Split result = 21600
	Case (0, 4, 2)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4', 'Nr. ¬(dom1) ([1,3)) == 2']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
			Nr. ¬(dom1) ([1,3)) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 0
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
					Nr. ¬(dom1) ([1,3)) == 2
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 4
					6 exchangeable free vars: ¬(dom2) ([1,5))
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 2
						----------
						Counting non-exchangeable...
						Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 2']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (3, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (1, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (2, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (4, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													4 different vars for 2 values!
													Counting domains: 0
												=========
												tot:0
										=========
										tot:0
								=========
								tot:0
							Case (0, 4)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 1']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (3, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (1, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (2, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (4, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (0, 4)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 0']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (3, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (1, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (2, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (4, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 4
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (0, 4)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4']:
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (4, 0, 2)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 4
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
			Nr. ¬(dom1) ([1,3)) == 2
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 4
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom1) ([1,3)) == 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 4
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 4
											Nr. dom2 ([5,10]) == 4 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 360
													Counting domains: 360
												=========
												tot:360
										=========
										tot:360
								=========
								tot:360
						=========
						tot:360
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 4 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 4 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							2 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 2
									Counting domains: 2
								=========
								tot:2
						=========
						tot:2
					Split result = 720
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 4
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (1, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (4, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 4', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 4
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 4
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 4)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:720
		=========
		tot:10800
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 4 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 4 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Case ¬(dom1) ([1,3))
	  Filtering 2 ¬(dom1) ([1,3)) out of dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]):
	  Filtering 2 ¬(dom1) ([1,3)) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]):
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
			dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10])
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 1', 'Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 1
					Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10]) are ['Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 0', 'Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 0
					Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,10])
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1
							Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 2
							Counting domains: 2
						=========
						tot:2
				=========
				tot:2
			Filtering domains...
			  Case ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8])
			  Case dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10])
			  Filtering 1 dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]) out of dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,10]):
				Subproblem:
				----------
				Solving 1 vars:
					dom1 ∧ ¬(dom2) ∧ ¬(dom1 ∧ ¬(dom2)) ((3,5) | (5,6) | (6,7) | (7,8) | (8,10])
				Choice constraints:
				Count constraints:
				----------
				Counting permutations:
				Falling factorial: 3
				Counting domains: 3
				=========
				tot:3
			Split result = 6
		Counting domains: 6
		=========
		tot:6
	Split result = 64800
	Case (3, 3, 0)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 3
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
			Nr. ¬(dom1) ([1,3)) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 3
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
					Nr. ¬(dom1) ([1,3)) == 0
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 120
													Counting domains: 120
												=========
												tot:120
										=========
										tot:120
								=========
								tot:120
						=========
						tot:120
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							3 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									3 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1 is unsat here
						==========
						Unsat: 0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 1', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 2 is unsat here
						==========
						Unsat: 0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
	Case (3, 0, 3)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 3
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
			Nr. ¬(dom1) ([1,3)) == 3
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 3
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom1) ([1,3)) == 3
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 1
											Nr. ¬(dom2) ([1,5)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 1
											Nr. dom2 ([5,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 2
											Nr. ¬(dom2) ([1,5)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 2
											Nr. dom2 ([5,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 0
											Nr. ¬(dom2) ([1,5)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 0
											Nr. dom2 ([5,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 0
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											dom2 ([5,10])
											dom2 ([5,10])
											dom2 ([5,10])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([5,10]) == 3
											Nr. ¬(dom2) ([1,5)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([5,10]) == 3
											Nr. dom2 ([5,10]) == 3 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													dom2 ([5,10])
													dom2 ([5,10])
													dom2 ([5,10])
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ([1,5)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ([1,5)) == 0
													Nr. ¬(dom2) ([1,5)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 120
													Counting domains: 120
												=========
												tot:120
										=========
										tot:120
								=========
								tot:120
						=========
						tot:120
					Filtering domains...
					  Case dom2 ([5,10])
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Filtering 3 dom2 ([5,10]) out of ¬(dom2) ([1,5)):
					  Case ¬(dom2) ([1,5))
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
							¬(dom2) ([1,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							3 exchangeable free vars: ¬(dom2) ([1,5))
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									3 different vars for 2 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 1
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 2: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 1']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 2', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 2
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 3: ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']
					Split class: dom2 ([5,10])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 1', 'Nr. ¬(dom2) ([1,5)) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 1
							Nr. ¬(dom2) ([1,5)) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 1
									Nr. ¬(dom2) ([1,5)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 1)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 2', 'Nr. ¬(dom2) ([1,5)) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 2
							Nr. ¬(dom2) ([1,5)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 2
									Nr. ¬(dom2) ([1,5)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 3)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ([1,5)) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 0
							Nr. ¬(dom2) ([1,5)) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 0
									Nr. ¬(dom2) ([1,5)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 0)
					Case dom2 ([5,10]) are ['Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 3', 'Nr. dom2 ([5,10]) == 3', 'Nr. ¬(dom2) ([1,5)) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom1) ([1,3)) == 3
							Nr. dom2 ([5,10]) == 3
							Nr. ¬(dom2) ([1,5)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									dom2 ([5,10])
									dom2 ([5,10])
									dom2 ([5,10])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. dom2 ([5,10]) == 3
									Nr. ¬(dom2) ([1,5)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (0, 3, 3)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3', 'Nr. ¬(dom1) ([1,3)) == 3']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
			Nr. ¬(dom1) ([1,3)) == 3
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 0
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
					Nr. ¬(dom1) ([1,3)) == 3
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 3
					6 exchangeable free vars: ¬(dom2) ([1,5))
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 3
						----------
						Counting non-exchangeable...
						Solving combination 0: ['Nr. ¬(dom1) ([1,3)) == 0'] // ['Nr. ¬(dom1) ([1,3)) == 3']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (2, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (0, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
							Case (3, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 0
									Nr. ¬(dom1) ([1,3)) == 0 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
											¬(dom2) ∧ dom1 ([3,5))
										Choice constraints:
										Count constraints:
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
													¬(dom2) ∧ dom1 ([3,5))
												Choice constraints:
												Count constraints:
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
												----------
												Counting exchangeable...
												Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													3 different vars for 2 values!
													Counting domains: 0
												=========
												tot:0
										=========
										tot:0
								=========
								tot:0
						Solving combination 1: ['Nr. ¬(dom1) ([1,3)) == 1'] // ['Nr. ¬(dom1) ([1,3)) == 2']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (2, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (0, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
							Case (3, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 1
									Nr. ¬(dom1) ([1,3)) == 1 is unsat here
								==========
								Unsat: 0
						Solving combination 2: ['Nr. ¬(dom1) ([1,3)) == 2'] // ['Nr. ¬(dom1) ([1,3)) == 1']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (2, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (0, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
							Case (3, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 2
									Nr. ¬(dom1) ([1,3)) == 2 is unsat here
								==========
								Unsat: 0
						Solving combination 3: ['Nr. ¬(dom1) ([1,3)) == 3'] // ['Nr. ¬(dom1) ([1,3)) == 0']
							Split class: ¬(dom2) ∧ dom1 ([3,5))
							Computing case combinations of rest classes...
							Case (1, 2)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 1
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
							Case (2, 1)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 2
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
							Case (0, 3)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 0
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
							Case (3, 0)
							Case ¬(dom2) ∧ dom1 ([3,5)) are ['Nr. ¬(dom1) ([1,3)) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0']:
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
									¬(dom2) ∧ dom1 ([3,5))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,10]) == 3
									Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom1) ([1,3)) == 3
									Nr. ¬(dom1) ([1,3)) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (0, 0, 6)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 6']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
			Nr. ¬(dom1) ([1,3)) == 6
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 0
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom1) ([1,3)) == 6
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					6 exchangeable free vars: ¬(dom2) ([1,5))
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
							¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 6
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom1) ([1,3)) == 6
							Nr. ¬(dom1) ([1,3)) == 6 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							6 different vars for 2 values!
							Counting domains: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (0, 6, 0)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 0', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 6', 'Nr. ¬(dom1) ([1,3)) == 0']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 6
			Nr. ¬(dom1) ([1,3)) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 0
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
					¬(dom2) ([1,5))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 6
					Nr. ¬(dom1) ([1,3)) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 6
					6 exchangeable free vars: ¬(dom2) ([1,5))
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
							¬(dom2) ∧ dom1 ([3,5))
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom1) ([1,3)) == 0
							Nr. ¬(dom1) ([1,3)) == 0 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							6 different vars for 2 values!
							Counting domains: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
	Case (6, 0, 0)
	Case universe ([1,10]) are ['Nr. dom2 ([5,10]) == 6', 'Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0', 'Nr. ¬(dom1) ([1,3)) == 0']:
		Subproblem:
		----------
		Solving 6 vars:
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
			universe ([1,10])
		Choice constraints:
		Count constraints:
			Nr. dom2 ([5,10]) == 6
			Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
			Nr. ¬(dom1) ([1,3)) == 0
		----------
		Counting exchangeable...
		Propagating Nr. dom2 ([5,10]) == 6
			6 exchangeable free vars: universe ([1,10])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 6 vars:
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
					dom2 ([5,10])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom1) ([1,3)) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0
					Nr. ¬(dom2) ∧ dom1 ([3,5)) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 6 vars:
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
							dom2 ([5,10])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom1) ([1,3)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom1) ([1,3)) == 0
							Nr. ¬(dom1) ([1,3)) == 0 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							Falling factorial: 720
							Counting domains: 720
						=========
						tot:720
				=========
				tot:720
		=========
		tot:720
	Filtering domains...
	  Case dom2 ([5,10])
	  Filtering 6 dom2 ([5,10]) out of dom2 ([5,10]):
	  Filtering 6 dom2 ([5,10]) out of dom1 ([3,10]):
	  Case ¬(dom2) ∧ dom1 ([3,5))
	  Case ¬(dom1) ([1,3))
		Subproblem:
		----------
		Solving 2 vars:
			dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10))
			dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10))
		Choice constraints:
		Count constraints:
		----------
		Counting permutations:
		Splitting injectivity...
			Split class: dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10))
			Computing case combinations of rest classes...
			Case (1, 0)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10)) are ['Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 1', 'Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10)) == 0']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 1
					Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10)) == 0
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 1
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 1 is unsat here
				==========
				Unsat: 0
			Case (0, 1)
			Case dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10)) are ['Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 0', 'Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10)) == 1']:
				Subproblem:
				----------
				Solving 1 vars:
					dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10))
				Choice constraints:
				Count constraints:
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 0
					Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10)) == 1
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 0
					Nr. ¬(dom1 ∧ ¬(dom2)) ([1,3) | [5] | [6] | [7] | [8] | [9] | [10]) == 0 already satisfied
					Splitting on other constraints...
						Subproblem:
						----------
						Solving 1 vars:
							dom2 ∧ ¬(dom2) ((5,6) | (6,7) | (7,8) | (8,9) | (9,10))
						Choice constraints:
						Count constraints:
							Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10)) == 1
							Nr. dom1 ∧ ¬(dom2) ([3,5) | (5,6) | (6,7) | (7,8) | (8,9) | (9,10)) == 1 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							1 different vars for 0 values!
							Counting domains: 0
						=========
						tot:0
				=========
				tot:0
		Counting domains: 0
		=========
		tot:0
	Split result = 0
Counting domains: 846720
=========
tot:846720

Running solver...
----------
Solving 12 vars:
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
	universe ([1,15])
Choice constraints:
Count constraints:
	Nr. ¬(dom2) ([1,6) | (13,15]) < 8
	Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
----------
Counting exchangeable...
Propagating Nr. ¬(dom2) ([1,6) | (13,15]) < 8
	Expanding bounds [0,7]...
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 0
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting exchangeable...
				Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
					Expanding bounds [0,1]...
						Subproblem:
						----------
						Solving 12 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
							Splitting on other constraints...
							... no other constraints
							Counting permutations:
							12 different vars for 8 values!
							Counting domains: 0
						=========
						tot:0
						Subproblem:
						----------
						Solving 12 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1 is unsat here
						==========
						Unsat: 0
				=========
				tot:0
		=========
		tot:0
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 1
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					¬(dom2) ([1,6) | (13,15])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							1 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 4
											Counting domains: 4
										=========
										tot:4
								=========
								tot:4
						=========
						tot:4
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 11 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
							Expanding bounds [0,1]...
								Subproblem:
								----------
								Solving 11 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									11 different vars for 8 values!
									Counting domains: 0
								=========
								tot:0
								Subproblem:
								----------
								Solving 11 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							1 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 1 vars:
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							1 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,6))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 3
											Counting domains: 3
										=========
										tot:3
								=========
								tot:3
						=========
						tot:3
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 1 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 11 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
							Expanding bounds [0,0]...
								Subproblem:
								----------
								Solving 11 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									11 different vars for 8 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
					Case (0, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 1 vars:
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							1 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 1 vars:
									¬(dom2) ∧ dom1 ([3,6))
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 2
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							2 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							2 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							2 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 12
											Counting domains: 12
										=========
										tot:12
								=========
								tot:12
						=========
						tot:12
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 10 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
							Expanding bounds [0,1]...
								Subproblem:
								----------
								Solving 10 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									10 different vars for 8 values!
									Counting domains: 0
								=========
								tot:0
								Subproblem:
								----------
								Solving 10 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							2 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
					Case (0, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							2 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 2 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							2 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 2 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 0
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 4
													Counting domains: 4
												=========
												tot:4
										=========
										tot:4
									Split result = 12
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:12
						=========
						tot:24
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 2 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 10 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
							Expanding bounds [0,0]...
								Subproblem:
								----------
								Solving 10 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									10 different vars for 8 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				=========
				tot:0
		=========
		tot:0
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 3
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 24
											Counting domains: 24
										=========
										tot:24
								=========
								tot:24
						=========
						tot:24
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 9 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
							Expanding bounds [0,1]...
								Subproblem:
								----------
								Solving 9 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									9 different vars for 8 values!
									Counting domains: 0
								=========
								tot:0
								Subproblem:
								----------
								Solving 9 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Split result = 0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
					Case (2, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 3
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 3 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							3 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 3 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 0
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 2 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 2 vars:
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 12
													Counting domains: 12
												=========
												tot:12
										=========
										tot:12
									Split result = 36
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:36
						=========
						tot:108
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 3 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 9 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
							Expanding bounds [0,0]...
								Subproblem:
								----------
								Solving 9 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									9 different vars for 8 values!
									Counting domains: 0
								=========
								tot:0
						=========
						tot:0
					Split result = 0
				=========
				tot:0
		=========
		tot:0
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 4
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (1, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (4, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											Falling factorial: 24
											Counting domains: 24
										=========
										tot:24
								=========
								tot:24
						=========
						tot:24
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 8 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
							Expanding bounds [0,1]...
								Subproblem:
								----------
								Solving 8 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 40320
									Counting domains: 40320
								=========
								tot:40320
								Subproblem:
								----------
								Solving 8 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:40320
					Split result = 967680
					Case (0, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (3, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 3
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
					Case (2, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (4, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 0
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 3 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 3 vars:
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 24
													Counting domains: 24
												=========
												tot:24
										=========
										tot:24
									Split result = 72
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:72
						=========
						tot:288
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 4 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 8 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
							Expanding bounds [0,0]...
								Subproblem:
								----------
								Solving 8 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 40320
									Counting domains: 40320
								=========
								tot:40320
						=========
						tot:40320
					Split result = 11612160
					Case (0, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 4 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							4 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 4 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 4
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				=========
				tot:12579840
		=========
		tot:6227020800
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 5
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (4, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (1, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (5, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 5
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											5 different vars for 4 values!
											Counting domains: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
					Case (0, 5)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (4, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 4
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
					Case (2, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 3
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (5, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 5
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. dom2 ([6,13]) == 0
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 4 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 4 vars:
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													Falling factorial: 24
													Counting domains: 24
												=========
												tot:24
										=========
										tot:24
									Split result = 72
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								=========
								tot:72
						=========
						tot:360
					Filtering domains...
					  Case ¬(dom2) ([1,6) | (13,15])
					  Filtering 5 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 5 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 5 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 5 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 5 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 5 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Filtering 5 ¬(dom2) ([1,6) | (13,15]) out of dom2 ([6,13]):
					  Case dom2 ([6,13])
						Subproblem:
						----------
						Solving 7 vars:
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
							dom2 ([6,13])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1
							Expanding bounds [0,0]...
								Subproblem:
								----------
								Solving 7 vars:
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
									dom2 ([6,13])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
									Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0 already satisfied
									Splitting on other constraints...
									... no other constraints
									Counting permutations:
									Falling factorial: 40320
									Counting domains: 40320
								=========
								tot:40320
						=========
						tot:40320
					Split result = 14515200
					Case (0, 5)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']:
						Subproblem:
						----------
						Solving 5 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							5 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 5 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 5
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				=========
				tot:14515200
		=========
		tot:11496038400
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 6
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (5, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 5
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (1, 5)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (4, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 6)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 6
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 6
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (6, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 6
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 6
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
									Nr. ¬(dom2) ([1,6) | (13,15]) == 6 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											6 different vars for 4 values!
											Counting domains: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (5, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 5
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. dom2 ([6,13]) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (1, 5)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 5
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 5
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 5
													Nr. dom2 ([6,13]) == 5 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 5
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 5
													Nr. dom2 ([6,13]) == 5 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
					Case (2, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 4
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 14: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (4, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 14: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 3
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 14: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 15: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 6)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 6
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 6
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (6, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 6 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 6
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							6 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 6 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 6
									Nr. dom2 ([6,13]) == 0
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 5 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 5 vars:
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													5 different vars for 4 values!
													Counting domains: 0
												=========
												tot:0
										=========
										tot:0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
		Subproblem:
		----------
		Solving 12 vars:
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
			universe ([1,15])
		Choice constraints:
		Count constraints:
			Nr. ¬(dom2) ([1,6) | (13,15]) == 7
			Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
		----------
		Counting exchangeable...
		Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 7
			12 exchangeable free vars: universe ([1,15])
			Splitting on other constraints...
				Subproblem:
				----------
				Solving 12 vars:
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					¬(dom2) ([1,6) | (13,15])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
					dom2 ([6,13])
				Choice constraints:
				Count constraints:
					Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2
				----------
				Counting non-exchangeable...
				Solving combination 0: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 2']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 6)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 6']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 6
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 6
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (6, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 6
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 6
									Nr. dom2 ([6,13]) == 1
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
									Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (2, 5)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 5']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 5
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (5, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 5
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. dom2 ([6,13]) == 2
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (3, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 4
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (4, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 3
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (0, 7)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 7']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 7
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 7
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
								==========
								Unsat: 0
						=========
						tot:0
					Case (7, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 7', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							Nr. ¬(dom2) ([1,6) | (13,15]) == 7
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 0
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 7
									Nr. dom2 ([6,13]) == 0
								----------
								Counting exchangeable...
								Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 7
									Nr. ¬(dom2) ([1,6) | (13,15]) == 7 already satisfied
									Splitting on other constraints...
										Subproblem:
										----------
										Solving 7 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. dom2 ([6,13]) == 0
											Nr. dom2 ([6,13]) == 0 already satisfied
											Splitting on other constraints...
											... no other constraints
											Counting permutations:
											7 different vars for 4 values!
											Counting domains: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
				Solving combination 1: ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1'] // ['Nr. ¬(dom2) ∧ dom1 ([3,6)) < 1']
					Split class: ¬(dom2) ([1,6) | (13,15])
					Computing case combinations of rest classes...
					Case (1, 6)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 6']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 1
							Nr. dom2 ([6,13]) == 6
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 1
									Nr. dom2 ([6,13]) == 6
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 6']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 6
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 5
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 5
													Nr. dom2 ([6,13]) == 5 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 5
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 5
													Nr. dom2 ([6,13]) == 5 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 6'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 6
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 6
													Nr. dom2 ([6,13]) == 6 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 6
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 6
													Nr. dom2 ([6,13]) == 6 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								=========
								tot:0
						=========
						tot:0
					Case (6, 1)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 1']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 6
							Nr. dom2 ([6,13]) == 1
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 6
									Nr. dom2 ([6,13]) == 1
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (2, 5)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 5']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 2
							Nr. dom2 ([6,13]) == 5
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 2
									Nr. dom2 ([6,13]) == 5
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 5
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 5
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 5
													Nr. dom2 ([6,13]) == 5 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 5
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 5
													Nr. dom2 ([6,13]) == 5 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 14: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 15: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 16: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 17: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (5, 2)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 2']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 5
							Nr. dom2 ([6,13]) == 2
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 5
									Nr. dom2 ([6,13]) == 2
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 2
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 14: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 15: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								Solving combination 16: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								Solving combination 17: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (3, 4)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 4']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 3
							Nr. dom2 ([6,13]) == 4
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 3
									Nr. dom2 ([6,13]) == 4
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 4
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 4
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 4
													Nr. dom2 ([6,13]) == 4 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 14: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 15: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 16: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 17: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 18: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 19: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (4, 3)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 3']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 4
							Nr. dom2 ([6,13]) == 3
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 4
									Nr. dom2 ([6,13]) == 3
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 3
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 1
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 1
													Nr. dom2 ([6,13]) == 1 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 2
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 2
													Nr. dom2 ([6,13]) == 2 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 3
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 3
													Nr. dom2 ([6,13]) == 3 is unsat here
												==========
												Unsat: 0
										=========
										tot:0
								Solving combination 8: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 9: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 10: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 11: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 12: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 13: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 14: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 15: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 16: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 17: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 18: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 19: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (0, 7)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 7']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 0
							Nr. dom2 ([6,13]) == 7
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 0
									Nr. dom2 ([6,13]) == 7
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 7']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 1
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 2
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 3
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 3']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 4', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 4
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 2']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 5', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 5
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 1']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 6', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 6
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 7'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 7', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 7
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 7', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 7
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
					Case (7, 0)
					Case ¬(dom2) ([1,6) | (13,15]) are ['Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1', 'Nr. ¬(dom2) ([1,6) | (13,15]) == 7', 'Nr. dom2 ([6,13]) == 0']:
						Subproblem:
						----------
						Solving 7 vars:
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
							¬(dom2) ([1,6) | (13,15])
						Choice constraints:
						Count constraints:
							Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							Nr. ¬(dom2) ([1,6) | (13,15]) == 7
							Nr. dom2 ([6,13]) == 0
						----------
						Counting exchangeable...
						Propagating Nr. ¬(dom2) ∧ dom1 ([3,6)) == 1
							7 exchangeable free vars: ¬(dom2) ([1,6) | (13,15])
							Splitting on other constraints...
								Subproblem:
								----------
								Solving 7 vars:
									¬(dom2) ∧ dom1 ([3,6))
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
									¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
								Choice constraints:
								Count constraints:
									Nr. ¬(dom2) ([1,6) | (13,15]) == 7
									Nr. dom2 ([6,13]) == 0
								----------
								Counting non-exchangeable...
								Solving combination 0: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 7', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 0
											Nr. ¬(dom2) ([1,6) | (13,15]) == 0 is unsat here
										==========
										Unsat: 0
								Solving combination 1: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1 already satisfied
															Splitting on other constraints...
																Subproblem:
																----------
																Solving 1 vars:
																	¬(dom2) ∧ dom1 ([3,6))
																Choice constraints:
																Count constraints:
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																----------
																Counting exchangeable...
																Propagating Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
																	Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0 already satisfied
																	Splitting on other constraints...
																	... no other constraints
																	Counting permutations:
																	Falling factorial: 3
																	Counting domains: 3
																=========
																tot:3
														=========
														tot:3
												=========
												tot:3
										=========
										tot:3
									Filtering domains...
									  Case ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13])
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Filtering 1 ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) out of ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]):
									  Case ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Subproblem:
										----------
										Solving 6 vars:
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
											¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 6 vars:
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
													¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15])
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
													... no other constraints
													Counting permutations:
													6 different vars for 4 values!
													Counting domains: 0
												=========
												tot:0
										=========
										tot:0
									Split result = 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 1
											Nr. ¬(dom2) ([1,6) | (13,15]) == 1 already satisfied
											Splitting on other constraints...
												Subproblem:
												----------
												Solving 1 vars:
													¬(dom2) ∧ dom1 ([3,6))
												Choice constraints:
												Count constraints:
													Nr. dom2 ([6,13]) == 0
													Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
													Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
												----------
												Counting exchangeable...
												Propagating Nr. dom2 ([6,13]) == 0
													Nr. dom2 ([6,13]) == 0 already satisfied
													Splitting on other constraints...
														Subproblem:
														----------
														Solving 1 vars:
															¬(dom2) ∧ dom1 ([3,6))
														Choice constraints:
														Count constraints:
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
														----------
														Counting exchangeable...
														Propagating Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
															Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0 is unsat here
														==========
														Unsat: 0
												=========
												tot:0
										=========
										tot:0
								Solving combination 2: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 2
											Nr. ¬(dom2) ([1,6) | (13,15]) == 2 is unsat here
										==========
										Unsat: 0
								Solving combination 3: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 3
											Nr. ¬(dom2) ([1,6) | (13,15]) == 3 is unsat here
										==========
										Unsat: 0
								Solving combination 4: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 3', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 4', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 4
											Nr. ¬(dom2) ([1,6) | (13,15]) == 4 is unsat here
										==========
										Unsat: 0
								Solving combination 5: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 2', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 5', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 5
											Nr. ¬(dom2) ([1,6) | (13,15]) == 5 is unsat here
										==========
										Unsat: 0
								Solving combination 6: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 1', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 6', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 6
											Nr. ¬(dom2) ([1,6) | (13,15]) == 6 is unsat here
										==========
										Unsat: 0
								Solving combination 7: ['Nr. ¬(dom2) ([1,6) | (13,15]) == 7', 'Nr. dom2 ([6,13]) == 0'] // ['Nr. ¬(dom2) ([1,6) | (13,15]) == 0', 'Nr. dom2 ([6,13]) == 0']
									Split class: ¬(dom2) ∧ dom1 ([3,6))
									Computing case combinations of rest classes...
									Case (1, 0)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 7', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 7
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 1
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 0
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 7
											Nr. ¬(dom2) ([1,6) | (13,15]) == 7 is unsat here
										==========
										Unsat: 0
									Case (0, 1)
									Case ¬(dom2) ∧ dom1 ([3,6)) are ['Nr. ¬(dom2) ([1,6) | (13,15]) == 7', 'Nr. dom2 ([6,13]) == 0', 'Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0', 'Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1']:
										Subproblem:
										----------
										Solving 1 vars:
											¬(dom2) ∧ dom1 ([3,6))
										Choice constraints:
										Count constraints:
											Nr. ¬(dom2) ([1,6) | (13,15]) == 7
											Nr. dom2 ([6,13]) == 0
											Nr. ¬(¬(dom2) ∧ ¬(¬(dom2) ∧ dom1)) ([3,13]) == 0
											Nr. ¬(dom2) ∧ ¬(¬(dom2) ∧ dom1) ([1,3) | (13,15]) == 1
										----------
										Counting exchangeable...
										Propagating Nr. ¬(dom2) ([1,6) | (13,15]) == 7
											Nr. ¬(dom2) ([1,6) | (13,15]) == 7 is unsat here
										==========
										Unsat: 0
								=========
								tot:0
						=========
						tot:0
				=========
				tot:0
		=========
		tot:0
=========
tot:17723059200
